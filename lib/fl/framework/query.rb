module Fl::Framework
  # Generic query support.
  # This module defines a number of general support methods used by various query packages.

  module Query
    protected

    # Generate the author lists from query options.
    # This method builds two lists, one that contains the fingerprints of authors to return
    # in the query, and one of authors to ignore in the query.
    #
    # The method expects the objects in the group lists to respond to the +members+ method, which returns
    # the list of group members.
    #
    # @param opts [Hash] A Hash containing configuration options for the query.
    # @option opts [Array<Object, String>, Object, String] :only_authors If given, return only comments
    #  generated by the given author or, if the value is an array, authors.
    #  The values are either objects, or strings containing the object's fingerprint
    #  (see {ActiveRecord::Base#fingerprint}).
    #  If a author is listed in both *:only_authors* and *:except_authors*, it is removed
    #  from *:only_authors* before the where clause component is generated; therefore, *:except_authors*
    #  has higher priority than *:only_authors*.
    # @option opts [Array<Object, String>, Object, String] :except_authors If given, return only comments
    #  not generated by the given author or, if the value is an array, authors.
    #  See the documentation for *:only_authors*.
    # @option opts [Array<Object, String>, Object, String] :only_groups If present, an array of group
    #  objects (or fingerprints) that contains the list used
    #  to limit the returned values to comments generated by authors in the groups. A single value
    #  is converted to an array. Note that the groups are converted to an array of author ids,
    #  for all the authors in the groups, and a where clause based on that list is added to the query.
    #  Therefore, this has a similar effect to the *:only_authors* option.
    #  If both expanded *:only_groups* and *:except_groups* values contain the same author id, that
    #  author is dropped from the expanded *:only_groups* list; therefore, *:except_groups* has higher
    #  precedence than *:only_groups*.
    # @option opts [Array<Object, String>, Object, String] :except_groups If given, return only comments
    #  not generated by any members of the group or,
    #  if the value is an array, groups. See the documentation for *:only_groups*.
    #  The *:except_groups* option expands to a list of object identifiers for authors whose comments
    #  should be excluded from the return value; therefore, *:except_groups* acts
    #  like *:except_authors*.
    #
    # @return [Hash] Returns a hash with two entries:
    #  - *:only_ids* is +nil+, to indicate that no "must-have" author selection is requested; or it is
    #    an array whose elements are authors' fingerprints.
    #  - *:except_ids* is +nil+, to indicate that no "must-not-have" author selection is requested; or it is
    #    an array whose elements are authors' fingerprints.

    def _expand_author_lists(opts)
      only_authors = opts[:only_authors]
      only_groups = opts[:only_groups]
      except_authors = opts[:except_authors]
      except_groups = opts[:except_groups]

      return {
        :only_ids => nil,
        :except_ids => nil
      } if only_authors.nil? && only_groups.nil? && except_authors.nil? && except_groups.nil?

      # 1. Build the arrays of object identifiers

      only_uids = if only_authors
                    t = (only_authors.is_a?(Array)) ? only_authors : [ only_authors ]
                    t.map { |u| (u.is_a?(String)) ? u : u.fingerprint }
                  else
                    nil
                  end

      if only_groups
        t = (only_groups.is_a?(Array)) ? only_groups : [ only_groups ]
        glist = t.map { |g| (g.is_a?(String)) ? ActiveRecord::Base.find_by_fingerprint(g) : g }

        only_gids = []
        glist.each do |g|
          if g
            g.members.each do |u|
              f = u.fingerprint
              only_gids << f unless only_gids.include?(f)
            end
          end
        end
      else
        only_gids = nil
      end

      except_uids = if except_authors
                      t = (except_authors.is_a?(Array)) ? except_authors : [ except_authors ]
                      t.map { |u| (u.is_a?(String)) ? u : u.fingerprint }
                    else
                      nil
                    end

      if except_groups
        t = (except_groups.is_a?(Array)) ? except_groups : [ except_groups ]
        glist = t.map { |g| (g.is_a?(String)) ? ActiveRecord::Base.find_by_fingerprint(g) : g }

        except_gids = []
        glist.each do |g|
          if g
            g.members.each do |u|
              f = u.fingerprint
              except_gids << f unless except_gids.include?(f)
            end
          end
        end
      else
        except_gids = nil
      end

      # 2. The list of author ids is the union of the groups/authors arrays

      only_ids = (only_uids.nil?) ? nil : only_uids
      unless only_gids.nil?
        if only_ids.nil?
          only_ids = only_gids 
        else
          only_ids |= only_gids 
        end
      end
      except_ids = (except_uids.nil?) ? nil : except_uids
      unless except_gids.nil?
        if except_ids.nil?
          except_ids = except_gids
        else
          except_ids |= except_gids
        end
      end

      # 3. Remove any except ids from the only list

      only_ids = only_ids - except_ids if only_ids.is_a?(Array) && except_ids.is_a?(Array)

      {
        :only_ids => only_ids,
        :except_ids => except_ids
      }
    end

    # Partition author lists.
    # Calls {#_partition_one_author_list} for each entry in _hlist_, and returns their partitioned values.
    #
    # @param [Hash] hlist A hash containing author lists.
    # @option hlist [Array<String>] :only_ids The fingerprints of the objects to place in the "must-have"
    #  clauses. Could be +nil+ if no "must-have" objects were requested.
    # @option hlist [Array<String>] :except_ids The fingerprints of the objects to place in the "must-not-have"
    #  clauses. Could be +nil+ if no "must-have" objects were requested.
    #
    # @return [Hash] Returns a hash containing two entries, *:only_ids* and *:except_ids*, generated as
    #  described above.

    def _partition_author_lists(hlist)
      h = { }

      if hlist.has_key?(:only_ids) && hlist[:only_ids]
        h[:only_ids] = _partition_one_author_list(hlist[:only_ids])
      else
        h[:only_ids] = nil
      end

      if hlist.has_key?(:except_ids) && hlist[:except_ids]
        h[:except_ids] = _partition_one_author_list(hlist[:except_ids])
      else
        h[:except_ids] = nil
      end

      h
    end

    # Partition a list of authors.
    # This method groups all authors whose fingerprints use the same class name, and places in the
    # return value an entry whose key is the class name, and whose value is an array of object identifiers
    # as extracted from the fingerprints.
    # This is how WHERE clauses will be set up.
    #
    # @param [Array<String>] clist An array of object fingerprints. A +nil+ value causes a +nil+ return value.
    #
    # @return [Hash] Returns a hash whose keys are the distinct class names from the fingerprints, and
    #  values the corresponding object identifiers. If _clist_ is +nil+, it returns +nil+.
    #  Note that the object identifiers are returned as strings, and for some ORMs (Active Record comes to
    #  mind...), they will likely have to be converted to integers in order to be used in WHERE clauses.
    
    def _partition_one_author_list(clist)
      return nil if clist.nil?

      h = { }
      clist.each do |f|
        if f
          cname, id = f.split('/')
          if h.has_key?(cname)
            h[cname] << id
          else
            h[cname] = [ id ]
          end
        end
      end

      h
    end

    # Sets up the parameters for time-related filters.
    # For each of the options listed below, the method places a corresponding entry in the return value
    # containing the timestamp generated from the entry.
    #
    # All parameters are either an integer containing a UNIX timestamp, a Time object, or a string
    # containing a string representation of the time; the value is converted to a
    # {Fl::Framework::Core::Icalendar::Datetime} and stored in that format.
    #
    # @param opts [Hash] A Hash containing configuration options for the query.
    # @option opts [Integer, Time, String] :updated_after to select comments updated after a given time.
    # @option opts [Integer, Time, String] :created_after to select comments created after a given time.
    # @option opts [Integer, Time, String] :updated_before to select comments updated before a given time.
    # @option opts [Integer, Time, String] :created_before to select comments created before a given time.
    #
    # @return [Hash] Returns a hash containing any number of the following keys; all values are timestamps.
    #  - *:c_after_ts* from *:created_after*.
    #  - *:c_before_ts* from *:created_before*.
    #  - *:u_after_ts* from *:updated_after*.
    #  - *:u_before_ts* from *:updated_before*.

    def _date_filter_timestamps(opts)
      rv = {}

      if opts.has_key?(:created_after)
        begin
          dt = Fl::Framework::Core::Icalendar::Datetime.new(opts[:created_after])
          rv[:c_after_ts] = dt if dt.valid?
        rescue => exc
        end
      end

      if opts.has_key?(:updated_after)
        begin
          dt = Fl::Framework::Core::Icalendar::Datetime.new(opts[:updated_after])
          rv[:u_after_ts] = dt if dt.valid?
        rescue => exc
        end
      end

      if opts.has_key?(:created_before)
        begin
          dt = Fl::Framework::Core::Icalendar::Datetime.new(opts[:created_before])
          rv[:c_before_ts] = dt if dt.valid?
        rescue => exc
        end
      end

      if opts.has_key?(:updated_before)
        begin
          dt = Fl::Framework::Core::Icalendar::Datetime.new(opts[:updated_before])
          rv[:u_before_ts] = dt if dt.valid?
        rescue => exc
        end
      end

      rv
    end

    # Parse the *:order* option and generate an order clause.
    # This method processes the *:order* key in _opts_ and generates an
    # array of converted order clauses.
    # 
    # @param opts [Hash] A hash of query options.
    # @option opts [String, Array] :order A string or array containing the <tt>ORDER BY</tt> clauses
    #  to process. The string value is converted to an array by splitting it at commas.
    #  A +false+ value or an empty string or array causes the option to be ignored.
    #  Defaults to <tt>updated_at DESC</tt>, so that the results are ordered by modification time, 
    #  with the most recent one listed first.
    #
    # @return [Array] Returns an array of converted order clauses.

    def _parse_order_option(opts)
      ord = case opts[:order]
            when String
              opts[:order].split(/,\s*/)
            when Array
              opts[:order]
            when FalseClass
              nil
            else
              [ 'updated_at DESC' ]
            end
      return nil if ord.nil? or (ord.count < 1)

      ord.map { |e| e.strip }
    end
  end
end
