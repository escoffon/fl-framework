module Fl::Framework::Comment::Neo4j
  # Neo4j-specific functionality for the comment management extension module.

  module Commentable
    # The methods in this module will be installed as class methods of the including class.

    module ClassMethods
    end

    # The methods in this module are installed as instance method of the including class.

    module InstanceMethods
      # Build a query to fetch an object's comments.
      #
      # @param opts [Hash] A Hash containing configuration options for the query.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :only_users If given, return only comments
      #  generated by the given user or, if the value is
      #  an array, users. If a user is listed in both +:only_users+ and +:except_users+, it is removed
      #  from +:only_users+ before the where clause component is generated; therefore, +:except_users+
      #  has higher priority than +:only_users+.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :except_users If given, return only comments
      #  not generated by the given user or, if the
      #  value is an array, users. See the documentation for +:only_users+.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :only_groups If present, an array of group
      #  objects (or IDs) that contains the list used
      #  to limit the returned values to comments generated by users in the groups. A single value
      #  is converted to an array. Note that the groups are converted to an array of user ids,
      #  for all the users in the groups, and a where clause based on that list is added to the query.
      #  Therefore, this has a similar effect to the +:only_users+ option.
      #  If both expanded +:only_groups+ and +:except_groups+ values contain the same user id, that
      #  user is dropped from the expanded +:only_groups+ list; therefore, +:except_groups+ has higher
      #  precedence than +:only_groups+.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :except_groups If given, return only comments
      #  not generated by any members of the group or,
      #  if the value is an array, groups. See the documentation for +:only_groups+.
      #  The +:except_groups+ option expands to a list of object identifiers for users whose comments
      #  should be excluded from the return value; therefore, +:except_groups+ acts
      #  like +:except_users+.
      # @option opts [Integer, Time] :updated_after adds a WHERE clause that selects comments that were updated
      #  after a given timestamp. The value for each option is the timestamp to compare (or a Time object).
      # @option opts [Integer, Time] :created_after adds a WHERE clause that selects comments that were created
      #  after a given timestamp. The value for each option is the timestamp to compare (or a Time object).
      # @option opts [Integer, Time] :updated_before adds a WHERE clause that selects comments that were updated
      #  before a given timestamp. The value for each option is the timestamp to compare (or a Time object).
      # @option opts [Integer, Time] :created_before adds a WHERE clause that selects comments that were created
      #  before a given timestamp. The value for each option is the timestamp to compare (or a Time object).
      #
      # Any WHERE clauses from +:updated_after+, +:created_after+, +:updated_before+, and +:created_before+
      # are concatenated using the AND operator.
      #
      # @return [Neo4j::Core::Query] Returns a query object containing the query to be executed.
      #  The following variables are bound in the query:
      #  - +commentable+ is the commentable object (+self+).
      #  - +comment_rel+ is the +COMMENT_FOR+ relationship between commentable and comment.
      #  - +comment+ is the comment object.
      #  - +owner+ is the comment's owner. This variable is present only if any of the +only_+ or +except_+
      #    options are present.
      # You can call additional query methods on the return value to modify the query; for example, to
      # add a +ORDER BY+ and +LIMIT+ clause:
      #  def get_last_comments(commentable, limit = 10)
      #   commentable.comments_query.order('comment.created_at DESC').limit(limit)
      #  end

      def comments_query(opts = {})
        return nil unless self.respond_to?(:comments)

        u_lists = _expand_user_lists(opts)
        match = "(commentable)<-[comment_rel:COMMENT_FOR]-(comment:`#{Fl::Comment::Comment.name}`)"
        where_clause = ''
        where_params = {}
        if !u_lists[:only_ids].nil? || !u_lists[:except_ids].nil?
          match << "<-[:IS_OWNER_OF]-(owner:`#{Fl::Core::User.name}`)"
        end
        if !u_lists[:only_ids].nil?
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(id(owner) IN {only_ids})'
          where_params[:only_ids] = u_lists[:only_ids]
        elsif !u_lists[:except_ids].nil?
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(NOT id(owner) IN {except_ids})'
          where_params[:except_ids] = u_lists[:except_ids]
        end

        ts = _date_filter_timestamps(opts)
        if ts[:c_after_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(comment.created_at > {c_after_ts})'
          where_params[:c_after_ts] = ts[:c_after_ts]
        end
        if ts[:u_after_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(comment.updated_at > {u_after_ts})'
          where_params[:u_after_ts] = ts[:u_after_ts]
        end
        if ts[:c_before_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(comment.created_at < {c_before_ts})'
          where_params[:c_before_ts] = ts[:c_before_ts]
        end
        if ts[:u_before_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(comment.updated_at < {u_before_ts})'
          where_params[:u_before_ts] = ts[:u_before_ts]
        end

        q = self.query_as(:commentable).match(match)
        q = q.where(where_clause, where_params) if where_clause.length > 0
        q
      end

      # Build a query to fetch an object's comments and subcomments.
      # Subcomments are comments associated with the top level comments.
      # This method adds a +WITH+ statement, followed by an +OPTIONAL_MATCH+ statement that picks up each
      # comment's subcomments.
      #
      # @param query [Neo4j::Core::Query] A query object as returned by {#comments_query} and possibly further
      #  modified.
      # @param opts [Hash] A hash containing configuration options for the query.
      # @option opts [String, Array<String, Symbol>] :with A string containing the list of variables
      #  returned by the +WITH+ statement. This value can also be an array of strings or symbols.
      #  The default value is the string +comment+,
      #  so that only the +comment+ variable is passed down to the +OPTIONAL_MATCH+ statement.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :only_users behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :except_users behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :only_groups behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :except_groups behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Integer] :updated_after behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Integer] :created_after behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Integer] :updated_before behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      # @option opts [Integer] :created_before behaves just like the equivalent
      #  configuration option for {#comments_query}, but applied to subcomments.
      #
      # @return [Neo4j::Core::Query] Returns a query object containing the query to be executed.
      #  By default, the following variables are bound in the query:
      #  - +comment+ is the comment object.
      #  - +subcomment_rel+ is the +COMMENT_FOR+ relationship between comment and subcomment.
      #  - +subcomment+ is the subcomment object.
      #  - +subowner+ is the subcomment's owner. This variable is present only if any of the +only_+ or
      #    +except_+ options are present.
      #  Additional variables may be bound, based on the value of the +:with+ option.
      #
      # Just as for #comments_query, the return value can be further modified. This example returns
      # the subcomments from the last N comments, ordered by creation time of the subcomment and grouped in an
      # array; also, only comments from specific users are returned.
      #  def get_last_comments_and_subcomments(commentable, limit = 10, users = nil)
      #   opts = {}
      #   opts[:only_users] = users unless users.nil?
      #
      #   cq = commentable.comments_query(opts).order('comment.created_at DESC').limit(limit)
      #   commentable.subcomments_query(cq, opts)\
      #     .with('comment, subcomment')\
      #     .order('comment.created_at DESC, subcomment.created_at DESC')\
      #     .return('comment, collect(subcomment) AS subcomments').order('comment.updated_at DESC')
      #  end
      # (This is more or less the query generated by [#comments_with_subcomments_query}.)

      def subcomments_query(query, opts = {})
        with_list = opts[:with] || 'comment'

        u_lists = _expand_user_lists(opts)
        match = "(comment)<-[subcomment_rel:COMMENT_FOR]-(subcomment:`#{Fl::Comment::Comment.name}`)"
        where_clause = ''
        where_params = {}
        if !u_lists[:only_ids].nil? || !u_lists[:except_ids].nil?
          match << "<-[:IS_OWNER_OF]-(subowner:`#{Fl::Core::User.name}`)"
        end
        if !u_lists[:only_ids].nil?
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(id(subowner) IN {s_only_ids})'
          where_params[:s_only_ids] = u_lists[:only_ids]
        elsif !u_lists[:except_ids].nil?
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(NOT id(subowner) IN {s_except_ids})'
          where_params[:s_except_ids] = u_lists[:except_ids]
        end

        ts = _date_filter_timestamps(opts)
        if ts[:c_after_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(subcomment.created_at > {sc_after_ts})'
          where_params[:sc_after_ts] = ts[:c_after_ts]
        end
        if ts[:u_after_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(subcomment.updated_at > {su_after_ts})'
          where_params[:su_after_ts] = ts[:u_after_ts]
        end
        if ts[:c_before_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(subcomment.created_at < {sc_before_ts})'
          where_params[:sc_before_ts] = ts[:c_before_ts]
        end
        if ts[:u_before_ts]
          where_clause << ' AND ' if where_clause.length > 0
          where_clause << '(subcomment.updated_at < {su_before_ts})'
          where_params[:su_before_ts] = ts[:u_before_ts]
        end

        q = query.with(with_list).optional_match(match)
        q = q.where(where_clause, where_params) if where_clause.length > 0

        q
      end

      # Utility method to fetch comments and subcomments.
      # This method uses {#comments_query} and {#subcomments_query} to generate a query, including a call
      # to +return+ to bind the selection variables.
      #
      # @param opts [Hash] A hash containing configuration options for the query.
      # @option opts [Integer] :max_comments The maximum number of comments to return.
      #  Defaults to all comments.
      # @option opts [Integer] :max_subcomments The maximum number of subcomments (per comment) to return.
      #  Defaults to all subcomments.
      # @option opts [Hash] :comment_opts A hash of configuration options to pass to {#comments_query}.
      #  Defaults to an empty hash.
      # @option opts [String] :comment_order A string containing the <tt>ORDER BY</tt> clause for the comments.
      #  Defaults to <tt>comment.created_at DESC</tt>, so that the comments are ordered by creation time, 
      #  with the most recent one listed first.
      # @option opts [Hash] :subcomment_opts A hash of configuration options to pass to {#subcomments_query}.
      #  Defaults to an empty Hash.
      # @option opts [String] :subcomment_order A string containing the <tt>ORDER BY</tt> clause for the
      #  subcomments.
      #  Defaults to <tt>subcomment.created_at DESC</tt>, so that the subcomments are ordered by creation time,
      #  wit the most recent one listed first.
      # @option opts [String] :return A string containing the <tt>RETURN</tt> clause for the query.
      #  Defaults to <tt>comment, collect(subcomment) AS subcomments</tt> (or an equivalent format), so that
      #  the query returns one row per comment, a +struct+ whose +comment+ property is the comment object,
      #  and +subcomments+ property an array of subcomments.
      #  Note that, if +:max_subcomments+ is defined, this option is ignored and the default value is used.
      #
      # The +:max_comments+ option is used to add a +LIMIT+ clause to the comments query, and therefore at
      # most that number of comments is returned by the pattern matching. The +:max_subcomments+ option
      # works by adding an extra +WITH+ statement to the query, and limiting the number of returned
      # subcomments via a range; the pattern matching itself always returns all subcomments, but the query
      # overall may trim off a number of the returned rows. What that means is that there is probably
      # no real performance advantage to using +:max_subcomments+ (and there may be a penalty instead),
      # and clients may be better off getting the full list and trimming it afterwards. On the other hand,
      # for comments that have a significant amount of subcomments, the extra step of trimming at the server
      # may offset having to send a number of unwanted subcomments with the response.
      # Also, if +:max_subcomments+ is defined, the query must be set up so that the +RETURN+ clause
      # returns one comment and a list of subcomments per row, and therefore the +:return+ option is
      # ignored.
      #
      # @example Return only the 10 most recent comments:
      #  q = o.comments_with_subcomments_query(max_comments: 10)
      # @example Return the 10 most recent comments by user +u1+:
      #  q = o.comments_with_subcomments_query(max_comments: 10, comment_opts: { only_users: u1 })
      # @example Return comments and subcomments from user +u1+ only:
      #  q = o.comments_with_subcomments_query(max_comments: 10, comment_opts: { only_users: u1 },
      #                                        subcomment_opts: { only_users: u1 })
      # @example Print the last 10 comments and their last 4 subcomments:
      #  sq = o.comments_with_subcomments_query(max_comments: 10, max_subcomments: 4)
      #  sq.each do |row|
      #    c = row.comment
      #    sc = row.subcomments
      #    print("++++ #{c.title} (#{c.user.username})\n")
      #    sc.each { |s| print("  ++ #{s.title} (#{s.user.username})\n") }
      #  end
      #
      # @return [Neo4j::Core::Query] Returns a query object containing the query to be executed.
      #  By default, the following variables are bound in the query:
      #  - +comment+ is the comment object.
      #  - +subcomments+ is an array containing subcomment objects for +comment+.
      #  Additional variables may be bound, based on the value of the +:return+ option.

      def comments_with_subcomments_query(opts = {})
        c_opts = opts[:comment_opts] || {}
        s_opts = opts[:subcomment_opts] || {}

        c_order = opts[:comment_order] || 'comment.created_at DESC'
        t = opts[:subcomment_order] || 'subcomment.created_at DESC'
        s_order = "#{c_order}, #{t}"

        max_comments = opts[:max_comments]
        max_subcomments = opts[:max_subcomments]

        cq = self.comments_query(c_opts).order(c_order)
        cq = cq.limit(max_comments) if max_comments

        sq = self.subcomments_query(cq, s_opts).with('comment, subcomment').order(s_order)
        if max_subcomments
          sq = sq.break.with('comment, collect(subcomment) AS sct')
          s_return = "comment, sct[0..#{max_subcomments}] AS subcomments"
        else
          s_return = opts[:subcomment_return] || 'comment, collect(subcomment) AS subcomments'
        end

        sq.return(s_return).order(c_order)
      end

      # Execute a query to fetch the number of comments associated with an object.
      # The number returned is actually subject to the configuration oprions +opts+; for example,
      # if <tt>opts[:only_users]</tt> is defined, the return value is the number of comments for +self+
      # and created by the given users.
      #
      # @param opts [Hash] A hash containing configuration options for the query.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :only_users behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Array<Fl::Core::User>, Fl::Core::User] :except_users behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :only_groups behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Array<Fl::Core::Group>, Fl::Core::Group] :except_groups behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Integer] :updated_after behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Integer] :created_after behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Integer] :updated_before behaves just like the equivalent
      #  configuration option for {#comments_query}.
      # @option opts [Integer] :created_before behaves just like the equivalent
      #  configuration option for {#comments_query}.
      #
      # @return [Integer] Returns the number of comments that would be returned by the query.

      def comments_count(opts = {})
        r = self.comments_query(opts).return('count(comment) AS ccount').to_a.first
        r.ccount
      end

      private

      def _expand_user_lists(opts)
        only_users = opts[:only_users]
        only_groups = opts[:only_groups]
        except_users = opts[:except_users]
        except_groups = opts[:except_groups]

        return {
          :only_ids => nil,
          :except_ids => nil
        } if only_users.nil? && only_groups.nil? && except_users.nil? && except_groups.nil?

        # 1. Build the arrays of object identifiers

        only_uids = if only_users
                      t = (only_users.is_a?(Array)) ? only_users : [ only_users ]
                      t.map { |u| (u.is_a?(Fl::Core::User)) ? u.neo_id : u }
                    else
                      nil
                    end

        if only_groups
          t = (only_groups.is_a?(Array)) ? only_groups : [ only_groups ]
          glist = t.map do |g|
            case g
            when Fl::Core::Group
              g
            else
              Fl::Core::Group.find(g)
            end
          end

          only_gids = []
          glist.each do |g|
            g.members.each do |u|
              only_gids << u.neo_id unless only_gids.include?(u.neo_id)
            end
          end
        else
          only_gids = nil
        end

        except_uids = if except_users
                        t = (except_users.is_a?(Array)) ? except_users : [ except_users ]
                        t.map { |u| (u.is_a?(Fl::Core::User)) ? u.neo_id : u }
                      else
                        nil
                      end

        if except_groups
          glist = except_groups.map do |g|
            case g
            when Fl::Core::Group
              g
            else
              Fl::Core::Group.find(g)
            end
          end

          except_gids = []
          glist.each do |g|
            g.members.each do |u|
              except_gids << u.neo_id unless except_gids.include?(u.neo_id)
            end
          end
        else
          except_gids = nil
        end

        # 2. The list of user ids is the union of the groups/users arrays

        only_ids = (only_uids.nil?) ? nil : only_uids
        unless only_gids.nil?
          if only_ids.nil?
            only_ids = only_gids 
          else
            only_ids |= only_gids 
          end
        end
        except_ids = (except_uids.nil?) ? nil : except_uids
        unless except_gids.nil?
          if except_ids.nil?
            except_ids = except_gids
          else
            except_ids |= except_gids
          end
        end

        # 3. Remove any except ids from the only list

        only_ids = only_ids - except_ids if only_ids.is_a?(Array) && except_ids.is_a?(Array)

        {
          :only_ids => only_ids,
          :except_ids => except_ids
        }
      end

      def _date_filter_timestamps(opts)
        rv = {}

        if opts.has_key?(:created_after)
          begin
            dt = Fl::Icalendar::Datetime.new(opts[:created_after])
            rv[:c_after_ts] = dt.to_i if dt.valid?
          rescue => exc
          end
        end

        if opts.has_key?(:updated_after)
          begin
            dt = Fl::Icalendar::Datetime.new(opts[:updated_after])
            rv[:u_after_ts] = dt.to_i if dt.valid?
          rescue => exc
          end
        end

        if opts.has_key?(:created_before)
          begin
            dt = Fl::Icalendar::Datetime.new(opts[:created_before])
            rv[:c_before_ts] = dt.to_i if dt.valid?
          rescue => exc
          end
        end

        if opts.has_key?(:updated_before)
          begin
            dt = Fl::Icalendar::Datetime.new(opts[:updated_before])
            rv[:u_before_ts] = dt.to_i if dt.valid?
          rescue => exc
          end
        end

        rv
      end
    end

    # Perform actions when the module is included.
    # - Checks that Neo4j::ActiveNode is included.
    # - Injects the class methods.
    # - Injects the instance methods.

    def self.included(base)
      unless self.include?(Neo4j::ActiveNode)
        raise "internal error: class #{self.name} must include Neo4j::ActiveNode to implement Neo4j queries"
      end

      base.extend ClassMethods

      base.instance_eval do
      end

      base.class_eval do
        include InstanceMethods
      end
    end
  end
end
